---
title: Viết test
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";
import testingOriginalTestFlutter from "!!raw-loader!/docs/cookbooks/testing_original_test_flutter.dart";
import testingOriginalTestDart from "!!raw-loader!/docs/cookbooks/testing_original_test_dart.dart";
import repositorySnippet from "!!raw-loader!/docs/cookbooks/testing_repository.dart";
import testFlutter from "!!raw-loader!/docs/cookbooks/testing_flutter.dart";
import testDart from "!!raw-loader!/docs/cookbooks/testing_dart.dart";
import testFull from "!!raw-loader!/docs/cookbooks/testing_full.dart";
import testOverrideInfo from "!!raw-loader!/docs/cookbooks/testing_override_info.dart";
import { trimSnippet } from "../../../../../src/components/CodeSnippet";

Đối với một app tầm trung đến lớn, việc kiểm tra chức năng của app là điều không
thể thiếu.

Để có thể test được app, chúng ta cần thỏa những điều kiện sau:

- Không nên giữ lại state giữa các `test`/`testWidgets`.  
  Điều này có nghĩa là không được có global state, hoặc các global state phải
  được reset sau mỗi test.

- Bắt buộc các provider phải có một state nhất định, bằng cách mocking hoặc điều
  khiển nó cho đến khi đạt được state mong muốn.

Hãy cùng xem cách [Riverpod] giúp bạn đạt được từng mục tiêu này.

## Không nên giữ lại state giữa các `test`/`testWidgets`.

Bởi vì provider thường được gán cho biến global, điều này có thể làm bạn lo
lắng.  
Dĩ nhiên, global state rất khó để test bởi vì nó cần những đoạn
`setup`/`tearDown` dài dòng.

Nhưng sự thật là: Dù provider được gán cho biến global, state của provider
**không phải** là global.

Thay vào đó, nó được trữ ở trong một [ProviderContainer], mà bạn đã có thể nhìn
thấy trong các ví dụ riêng cho Dart.  
Nếu bạn chưa tham khảo các ví dụ đó, bạn chỉ cần biết [ProviderContainer] được
tạo bởi [ProviderScope], widget cho phép chúng ta sử dụng [Riverpod].

Concretely what this means is, two `testWidgets` using providers do not share
any state.  
As such, there is no need for any `setUp`/`tearDown` at all.

But an example is better than lengthy explanations:

<Tabs
  defaultValue="testWidgets"
  values={[
    { label: 'testWidgets (Flutter)', value: 'testWidgets', },
    { label: 'test (Dart only)', value: 'test', },
  ]}
>
<TabItem value="testWidgets">

<CodeBlock>{trimSnippet(testingOriginalTestFlutter)}</CodeBlock>

</TabItem>
<TabItem value="test">

<CodeBlock>{trimSnippet(testingOriginalTestDart)}</CodeBlock>

</TabItem>
</Tabs>

As you can see, while `counterProvider` was declared as a global, no state was
shared between tests.  
As such, we do not have to worry about our tests potentially behaving
differently if executed in a different order, since they are running in complete
isolation.

## Overriding the behavior of a provider during tests.

A common real-world application may have the following objects:

- It will have a `Repository` class, which provides a type-safe and simple API
  to perform HTTP requests.

- An object that manages the application state, and may use `Repository` to
  perform HTTP requests based on different factors.  
  This may be a `ChangeNotifier`, `Bloc`, or even a provider.

Using [Riverpod], this may be represented as follows:

<CodeBlock>{trimSnippet(repositorySnippet)}</CodeBlock>

In this situation, when making a unit/widget test, we will typically want to
replace our `Repository` instance with a fake implementation that returns a
pre-defined response instead of making a real HTTP request.

We will then want our `todoListProvider` or equivalent to use the mocked
implementation of `Repository`.

To achieve this, we can use the `overrides` parameter of
[ProviderScope]/[ProviderContainer] to override the behavior of
`repositoryProvider`:

<Tabs
  defaultValue="ProviderScope"
  values={[
    { label: 'ProviderScope (Flutter)', value: 'ProviderScope', },
    { label: 'ProviderContainer (Dart only)', value: 'ProviderContainer', },
  ]}
>
<TabItem value="ProviderScope">

<CodeBlock>{trimSnippet(testFlutter)}</CodeBlock>

</TabItem>
<TabItem value="ProviderContainer">

<CodeBlock>{trimSnippet(testDart)}</CodeBlock>

</TabItem>
</Tabs>

As you can see by the highlighted code, [ProviderScope]/[ProviderContainer]
allows replacing the implementation of a provider with a different behavior.

:::info Some providers expose simplified ways to override their behavior.  
For example, [FutureProvider] allows overriding the provider with an
`AsyncValue`:

<CodeBlock>{trimSnippet(testOverrideInfo)}</CodeBlock>

:::

:::info The syntax for overriding a provider with the `family` modifier is
slightly different.

If you used a provider like this:

```dart
final response = ref.watch(myProvider('12345'));
```

You could override the provider as:

```dart
myProvider('12345').overrideWithValue(...));
```

:::

## Full widget test example

Wrapping up, here is the entire full code for our Flutter test.

<CodeBlock>{trimSnippet(testFull)}</CodeBlock>

[riverpod]: https://github.com/rrousselgit/river_pod
[providerscope]:
  https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html
[providercontainer]:
  https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html
[futureprovider]:
  https://pub.dev/documentation/riverpod/latest/riverpod/FutureProvider-class.html
[zone]: https://api.flutter.dev/flutter/dart-async/Zone-class.html
